import time

import polars as pl
import polars.selectors as cs

from bank_statement_parser.modules.classes.statement_classes import Statement, StatementTable
from bank_statement_parser.modules.config import config_companies_df
from bank_statement_parser.modules.constants import NUMBERS_GBP, STRIP_GBP_USD
from bank_statement_parser.modules.currency import currency_spec
from bank_statement_parser.modules.functions.pdf_functions import page_crop, region_table
from bank_statement_parser.modules.functions.statement_functions import extract_table_fields, spawn_locations

stmt = Statement("/home/boscorat/Downloads/2025-07-08_Statement_Advance_Account.pdf")
DEBUG = False


def get_region(location, pdf):
    region = None
    exception = None
    if location.page_number:
        try:
            region = page_crop(pdf.pages[location.page_number - 1], location.top_left, location.bottom_right)
        except IndexError:
            exception = "Page doesn't exist in Statement"
        except ValueError:
            exception = "Specified location outside of the page boundaries"
    else:
        exception = "No page number specified for the location"
    return (region, exception)


def get_table(location, region, statement_table):
    table = pl.LazyFrame()
    table = region_table(
        region=region,
        table_rows=statement_table.table_rows,
        table_columns=statement_table.table_columns,
        row_spacing=statement_table.row_spacing,
        vertical_lines=location.vertical_lines,
    )
    return table


def strip(data, field, spec=None):
    src = "raw"
    step = "strip"
    if DEBUG:
        print(f"{step}: {field.field}")
        print("Before...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)
    data = data.with_columns(
        pl.col(f"value_{src}").fill_null("").alias(f"value_{step}"),
        pl.lit(False).alias(f"success_{step}"),
        pl.lit(f"{step} error").alias(f"error_{step}"),
    )
    if field.strip_characters_start:
        data = data.with_columns(
            pl.col(f"value_{step}").str.strip_chars_start(field.strip_characters_start).fill_null("").alias(f"value_{step}")
        )
    if field.strip_characters_end:
        data = data.with_columns(
            pl.col(f"value_{step}").str.strip_chars_end(field.strip_characters_end).fill_null("").alias(f"value_{step}")
        )

    if spec and field.type == "numeric":
        data = data.with_columns(
            pl.col(f"value_{step}")
            .str.replace_many(spec.symbols, [""])
            .str.replace_many(spec.seperators_thousands, [""])
            .str.replace_many([r"\s"], [""])
            .fill_null("")
            .alias(f"value_{step}")  # always remove any whitespace
        )

    data = data.with_columns(
        ((pl.col(f"value_{step}").is_not_null()) & (pl.col(f"value_{step}").str.len_bytes() > 0)).alias(f"success_{step}")
    ).with_columns(pl.when(pl.col(f"success_{step}")).then(None).otherwise(pl.col(f"error_{step}")).alias(f"error_{step}"))
    if DEBUG:
        print("After...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)
    return data


def patmatch(data, field, spec=None):
    src = "strip"
    step = "pattern"
    if DEBUG:
        print(f"{step}: spec: {spec.pattern if spec else field.string_pattern}")
        print("Before...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)
    data = data.with_columns(
        pl.lit("").alias(f"value_{step}"),
        pl.lit(False).alias(f"success_{step}"),
        pl.lit(f"{step} error").alias(f"error_{step}"),
    )
    if spec:
        data = data.with_columns(pl.col(f"value_{src}").str.extract(spec.pattern, 0).fill_null("").alias(f"value_{step}"))
    else:
        data = data.with_columns(pl.col(f"value_{src}").str.extract(field.string_pattern, 0).fill_null("").alias(f"value_{step}"))
    data = data.with_columns(
        ((pl.col(f"value_{step}").is_not_null()) & (pl.col(f"value_{step}").str.len_bytes() > 0)).alias(f"success_{step}")
    ).with_columns(pl.when(pl.col(f"success_{step}")).then(None).otherwise(pl.col(f"error_{step}")).alias(f"error_{step}"))
    if DEBUG:
        print("After...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)
    return data


def cast(data, field):
    src = "pattern"
    step = "cast"
    if DEBUG:
        print(f"{step}: {field.numeric_modifier}")
        print("Before...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)
    data = data.with_columns(
        pl.lit("").alias(f"value_{step}"),
        pl.lit(False).alias(f"success_{step}"),
        pl.lit(f"{step} error").alias(f"error_{step}"),
    )
    if field.type == "numeric":
        if field.numeric_modifier:
            if field.numeric_modifier.prefix or field.numeric_modifier.suffix:
                if field.numeric_modifier.prefix:
                    data = data.with_columns(
                        pl.when(pl.col(f"value_{src}").str.starts_with(field.numeric_modifier.prefix))
                        .then(
                            pl.col(f"value_{src}")
                            .str.strip_chars_start(field.numeric_modifier.prefix)
                            .cast(float)
                            .mul(field.numeric_modifier.multiplier)
                        )
                        .otherwise(pl.col(f"value_{src}").cast(float, strict=False))
                        .alias(f"value_{step}")
                    )
                elif field.numeric_modifier.suffix:
                    data = data.with_columns(
                        pl.when(pl.col(f"value_{src}").str.ends_with(field.numeric_modifier.suffix))
                        .then(
                            pl.col(f"value_{src}")
                            .str.strip_chars_end(field.numeric_modifier.suffix)
                            .cast(float, strict=False)
                            .mul(field.numeric_modifier.multiplier)
                        )
                        .otherwise(pl.col(f"value_{src}").cast(float, strict=False))
                        .alias(f"value_{step}")
                    )
            else:
                data = data.with_columns(
                    pl.col(f"value_{src}").cast(float, strict=False).mul(field.numeric_modifier.multiplier).alias(f"value_{step}")
                )
            if field.numeric_modifier.exclude_negative_values:
                data = data.with_columns(pl.when(pl.col(f"value_{step}") < 0).then(pl.lit(0.00)).alias(f"value_{step}"))
            if field.numeric_modifier.exclude_positive_values:
                data = data.with_columns(pl.when(pl.col(f"value_{step}") > 0).then(pl.lit(0.00)).alias(f"value_{step}"))
        else:
            data = data.with_columns(pl.col(f"value_{src}").cast(float, strict=False).alias(f"value_{step}"))
    elif field.type == "string":
        data = data.with_columns(pl.col(f"value_{src}").cast(str, strict=False).alias(f"value_{step}"))

    # cast the value back as a string so we don't get mixed types in the column value_cast column
    data = data.with_columns(pl.col(f"value_{step}").cast(str).fill_null("").alias(f"value_{step}"))
    if field.type == "numeric":
        data = data.with_columns(pl.col(f"value_{step}").str.to_decimal(scale=2).cast(str).alias(f"value_{step}"))

    data = data.with_columns(
        ((pl.col(f"value_{step}").is_not_null()) & (pl.col(f"value_{step}").str.len_bytes() > 0)).alias(f"success_{step}")
    ).with_columns(pl.when(pl.col(f"success_{step}")).then(None).otherwise(pl.col(f"error_{step}")).alias(f"error_{step}"))
    if DEBUG:
        print("After...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)
    return data


def trim(data, field):
    src = "cast"
    step = "trim"
    if DEBUG:
        print(f"{step}: {field.string_max_length}")
        print("Before...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)
    data = data.with_columns(
        pl.lit("").alias(f"value_{step}"),
        pl.lit(False).alias(f"success_{step}"),
        pl.lit(f"{step} error").alias(f"error_{step}"),
    )
    string_max_length = field.string_max_length if field.string_max_length else 999
    if field.type == "string":
        data = data.with_columns(pl.col(f"value_{src}").str.head(string_max_length).fill_null("").alias(f"value_{step}"))
    else:
        data = data.with_columns(pl.col(f"value_{src}").fill_null("").alias(f"value_{step}"))
    data = data.with_columns(
        ((pl.col(f"value_{step}").is_not_null()) & (pl.col(f"value_{step}").str.len_bytes() > 0)).alias(f"success_{step}")
    ).with_columns(pl.when(pl.col(f"success_{step}")).then(None).otherwise(pl.col(f"error_{step}")).alias(f"error_{step}"))
    if DEBUG:
        print("After...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)
    return data


def validate(data, field):
    src = "trim"
    if DEBUG:
        print("Validate")
        print("Before...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)

    data = data.with_columns(
        value=pl.col(f"value_{src}"),
        success=pl.concat_list(cs.starts_with("success_")).list.all(),
        error=pl.concat_list(cs.starts_with("error_")).list.drop_nulls().list.first(),
    ).with_columns(hard_fail=~pl.col("success") & field.vital)
    if DEBUG:
        print("After...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)
    return data


def cleanup(data):
    if not DEBUG:
        data = data.select("row", "page", "field", "vital", "value", "success", "error", "hard_fail")
    return data


def extract_table_fields_df(pdf, location, statement_table):
    region, exception = get_region(location, pdf)
    table = get_table(location, region, statement_table) if region and not exception else pl.LazyFrame()
    table = table.collect().lazy()
    # table = table.collect()
    result: pl.LazyFrame = pl.LazyFrame()
    # result: pl.DataFrame = pl.DataFrame()
    results: pl.DataFrame = pl.DataFrame()

    if statement_table.transaction_spec:  # transaction records will be multi-line and have now row specification
        for field in statement_table.fields:
            result = table.select(
                page=pl.lit(location.page_number), field=pl.lit(field.field), vital=pl.lit(field.vital), value_raw=pl.nth(field.column)
            ).with_row_index("row")
            spec = None
            if field.type == "numeric":
                spec = currency_spec[field.numeric_currency]
            result = (
                result.pipe(strip, field, spec)
                .pipe(patmatch, field, spec)
                .pipe(cast, field)
                .pipe(trim, field)
                .pipe(validate, field)
                .pipe(cleanup)
            )
            try:
                results.vstack(result.collect(), in_place=True)
                # results.vstack(result, in_place=True)
            except pl.exceptions.ColumnNotFoundError:
                continue

    else:  # other table records will be row and column specific
        # result_eager: pl.DataFrame = pl.DataFrame()
        table_eager: pl.DataFrame = table.collect()
        # table_eager: pl.DataFrame = table
        for field in statement_table.fields:
            result = pl.LazyFrame(
                data=[
                    pl.Series("field", [field.field], dtype=pl.String),
                    pl.Series("vital", [field.vital], dtype=pl.Boolean),
                    pl.Series("value_raw", [table_eager.item(field.cell.row, field.cell.col)], dtype=pl.String),
                ]
            )
            result = result.select(
                pl.lit(field.cell.row).alias("row"),
                pl.lit(location.page_number).alias("page"),
                pl.col("field"),
                pl.col("vital"),
                pl.col("value_raw"),
            )
            spec = None
            if field.type == "numeric":
                spec = currency_spec[field.numeric_currency]
            result = (
                result.pipe(strip, field, spec)
                .pipe(patmatch, field, spec)
                .pipe(cast, field)
                .pipe(trim, field)
                .pipe(validate, field)
                .pipe(cleanup)
            )
            try:
                results.vstack(result.collect(), in_place=True)
                # results.vstack(result, in_place=True)
            except pl.exceptions.ColumnNotFoundError:
                continue

    return (results.lazy(), results.filter(pl.col("success")).lazy())


# def extract_table_fields_df(pdf, location, statement_table):
#     region, exception = get_region(location, pdf)
#     table = get_table(location, region, statement_table).collect() if region and not exception else pl.DataFrame()
#     # table = table.collect().lazy()
#     result: pl.DataFrame = pl.DataFrame()
#     results: pl.DataFrame = pl.DataFrame()

#     if statement_table.transaction_spec:  # transaction records will be multi-line and have now row specification
#         for field in statement_table.fields:
#             try:
#                 result = table.select(field=pl.lit(field.field), vital=pl.lit(field.vital), value_raw=pl.nth(field.column)).with_row_index(
#                     "row"
#                 )
#             except pl.exceptions.ColumnNotFoundError:
#                 continue
#             spec = None
#             if field.type == "numeric":
#                 spec = currency_spec[field.numeric_currency]
#             result = (
#                 result.pipe(strip, field, spec)
#                 .pipe(patmatch, field, spec)
#                 .pipe(cast, field)
#                 .pipe(trim, field)
#                 .pipe(validate, field)
#                 .pipe(cleanup)
#             )
#             try:
#                 results.vstack(result, in_place=True)
#                 del result
#             except pl.exceptions.ColumnNotFoundError:
#                 del result
#                 continue

#     # else:  # other table records will be row and column specific
#     #     # result_eager: pl.DataFrame = pl.DataFrame()
#     #     table_eager: pl.DataFrame = table.collect()
#     #     for field in statement_table.fields:
#     #         result = pl.LazyFrame(
#     #             data=[
#     #                 pl.Series("field", [field.field], dtype=pl.String),
#     #                 pl.Series("vital", [field.vital], dtype=pl.Boolean),
#     #                 pl.Series("value_raw", [table_eager.item(field.cell.row, field.cell.col)], dtype=pl.String),
#     #             ]
#     #         )
#     #         spec = None
#     #         if field.type == "numeric":
#     #             spec = currency_spec[field.numeric_currency]
#     #         result = (
#     #             result.pipe(strip, field, spec)
#     #             .pipe(patmatch, field, spec)
#     #             .pipe(cast, field)
#     #             .pipe(trim, field)
#     #             .pipe(validate, field)
#     #             .pipe(cleanup)
#     #         )
#     #         results.vstack(result.collect(), in_place=True)
#     # del region, exception, table
#     return results


# if stmt.config_header:
#     for config in stmt.config_header:
#         # extract field values
#         if config.statement_table:
#             spawned_locations = spawn_locations(config.statement_table.locations, stmt.pdf)
#             for location in spawned_locations:
#                 # table_fields = extract_table_fields(stmt.pdf, location, config.statement_table)
#                 table_fields_df = extract_table_fields_df(stmt.pdf, location, config.statement_table)[1]
#                 with pl.Config(tbl_cols=-1, tbl_rows=-1):
#                     print(table_fields_df.collect())
#                 ...
# if stmt.config_pages:
#     for config in stmt.config_pages:
#         # extract field values
#         if config.statement_table:
#             spawned_locations = spawn_locations(config.statement_table.locations, stmt.pdf)
#             for location in spawned_locations:
#                 # table_fields = extract_table_fields(stmt.pdf, location, config.statement_table)
#                 table_fields_df = extract_table_fields_df(stmt.pdf, location, config.statement_table)[1]
#                 with pl.Config(tbl_cols=-1, tbl_rows=-1):
#                     print(table_fields_df.collect())
#                 ...
if stmt.config_lines:
    for config in stmt.config_lines:
        # extract field values
        if config.statement_table:
            spawned_locations = spawn_locations(config.statement_table.locations, stmt.pdf)

            # start_old = time.time()
            # for location in spawned_locations:
            #     for i in range(5):
            #         # print("old", location, i)
            #         table_fields = extract_table_fields(stmt.pdf, location, config.statement_table)
            # end_old = time.time()

            start_new = time.time()
            for location in spawned_locations:
                for _ in range(1):
                    # if location.page_number == 2:
                    table_fields_df = extract_table_fields_df(stmt.pdf, location, config.statement_table)[1]
                    with pl.Config(tbl_cols=-1, tbl_rows=-1):
                        print(table_fields_df.collect())
            end_new = time.time()

            # start_new2 = time.time()
            # for location in spawned_locations:
            #     for i in range(5):
            #         table_fields_df2 = extract_table_fields_df2(stmt.pdf, location, config.statement_table)
            # end_new2 = time.time()

            # start_new3 = time.time()
            # for location in spawned_locations:
            #     for _ in range(5):
            #         table_fields_df = extract_table_fields_df(stmt.pdf, location, config.statement_table)
            # end_new3 = time.time()

            # start_new4 = time.time()
            # for location in spawned_locations:
            #     for i in range(5):
            #         table_fields_df2 = extract_table_fields_df2(stmt.pdf, location, config.statement_table)
            # end_new4 = time.time()

            # print("old: ", {end_old - start_old}, "secs")
            print("new: ", {end_new - start_new}, "secs")
            # print("new2: ", {end_new2 - start_new2}, "secs")
            # print("new3: ", {end_new3 - start_new3}, "secs")
            # print("new4: ", {end_new4 - start_new4}, "secs")
            # with pl.Config(tbl_cols=-1, tbl_rows=-1):
            #     print(table_fields_df.filter(pl.col("success")))
            ...
