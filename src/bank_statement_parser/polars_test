import time

import polars as pl
import polars.selectors as cs

from bank_statement_parser.modules.classes.data_definitions import Config
from bank_statement_parser.modules.classes.errors import StatementError
from bank_statement_parser.modules.classes.statement_classes import Statement, StatementTable
from bank_statement_parser.modules.config import config_accounts, config_companies, config_company_accounts
from bank_statement_parser.modules.constants import NUMBERS_GBP, STRIP_GBP_USD
from bank_statement_parser.modules.currency import currency_spec
from bank_statement_parser.modules.functions.pdf_functions import page_crop, region_table
from bank_statement_parser.modules.functions.statement_functions import extract_table_fields, spawn_locations

log = []

# stmt = Statement("/home/boscorat/Downloads/2025-07-08_Statement_Advance_Account.pdf")
# stmt = Statement("/home/boscorat/Downloads/2025-07-08_Statement_Flexible_Saver.pdf")
stmt = Statement("/home/boscorat/Downloads/2025-07-12_Statement_Rewards_Credit_Card.pdf")
DEBUG = False


def get_region(location, pdf):
    start = time.time()
    region = None
    exception = None
    if location.page_number:
        try:
            region = page_crop(pdf.pages[location.page_number - 1], location.top_left, location.bottom_right)
        except IndexError:
            exception = "Page doesn't exist in Statement"
        except ValueError:
            exception = "Specified location outside of the page boundaries"
    else:
        exception = "No page number specified for the location"
    log.append(["get_region", time.time() - start])
    return (region, exception)


def get_table(location, region, statement_table):
    start = time.time()
    table = pl.LazyFrame()
    table = region_table(
        region=region,
        table_rows=statement_table.table_rows,
        table_columns=statement_table.table_columns,
        row_spacing=statement_table.row_spacing,
        vertical_lines=location.vertical_lines,
    )
    log.append(["get_table", time.time() - start])
    return table


def strip(data, field, spec=None):
    start = time.time()
    src = "raw"
    step = "strip"
    if DEBUG:
        print(f"{step}: {field.field}")
        print("Before...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)
    data = data.with_columns(
        pl.col(f"value_{src}").fill_null("").alias(f"value_{step}"),
        pl.lit(False).alias(f"success_{step}"),
        pl.lit(f"{step} error").alias(f"error_{step}"),
    )
    if field.strip_characters_start:
        data = data.with_columns(
            pl.col(f"value_{step}").str.strip_chars_start(field.strip_characters_start).fill_null("").alias(f"value_{step}")
        )
    if field.strip_characters_end:
        data = data.with_columns(
            pl.col(f"value_{step}").str.strip_chars_end(field.strip_characters_end).fill_null("").alias(f"value_{step}")
        )

    if spec and field.type == "numeric":
        data = data.with_columns(
            pl.col(f"value_{step}")
            .str.replace_many(spec.symbols, [""])
            .str.replace_many(spec.seperators_thousands, [""])
            .str.replace_many([r"\s"], [""])
            .fill_null("")
            .alias(f"value_{step}")  # always remove any whitespace
        )

    data = data.with_columns(
        ((pl.col(f"value_{step}").is_not_null()) & (pl.col(f"value_{step}").str.len_bytes() > 0)).alias(f"success_{step}")
    ).with_columns(pl.when(pl.col(f"success_{step}")).then(None).otherwise(pl.col(f"error_{step}")).alias(f"error_{step}"))
    if DEBUG:
        print("After...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)

    log.append(["strip", time.time() - start])
    return data


def build_pattern(string_pattern=None, spec_pattern=None, prefix=None, suffix=None):
    start = time.time()
    pattern: str = r".+"
    if string_pattern is not None:
        pattern = string_pattern
        log.append(["build_pattern", time.time() - start])
        return pattern
    elif spec_pattern is not None:
        pattern = spec_pattern
        if prefix is None and suffix is None:
            return pattern
        if prefix is not None:
            pattern = str(pattern).replace("^", rf"^({prefix})?\s?")
        if suffix is not None:
            pattern = str(pattern).replace("$", rf"\s?({suffix})?$")
    log.append(["build_pattern", time.time() - start])
    return pattern


def patmatch(data, field, spec=None):
    start = time.time()
    src = "strip"
    step = "pattern"
    pattern = build_pattern(
        string_pattern=field.string_pattern,
        spec_pattern=spec.pattern if spec else None,
        prefix=field.numeric_modifier.prefix if field.numeric_modifier else None,
        suffix=field.numeric_modifier.suffix if field.numeric_modifier else None,
    )
    if DEBUG:
        print(f"{step}: spec: {pattern}")
        print("Before...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data.collect())
    data = data.with_columns(
        pl.lit("").alias(f"value_{step}"),
        pl.lit(False).alias(f"success_{step}"),
        pl.lit(f"{step} error").alias(f"error_{step}"),
    )
    # if spec:
    #     data = data.with_columns(
    #         pl.col(f"value_{src}")
    #         .str.extract(
    #             spec.pattern,
    #             0,
    #         )
    #         .fill_null("")
    #         .alias(f"value_{step}")
    #     )
    # else:
    data = data.with_columns(pl.col(f"value_{src}").str.extract(pattern, 0).fill_null("").alias(f"value_{step}"))
    data = data.with_columns(
        ((pl.col(f"value_{step}").is_not_null()) & (pl.col(f"value_{step}").str.len_bytes() > 0)).alias(f"success_{step}")
    ).with_columns(pl.when(pl.col(f"success_{step}")).then(None).otherwise(pl.col(f"error_{step}")).alias(f"error_{step}"))
    if DEBUG:
        print("After...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data.collect())
    log.append(["pat_match", time.time() - start])
    return data


def cast(data, field):
    start = time.time()
    src = "pattern"
    step = "cast"
    if DEBUG:
        print(f"{step}: {field.numeric_modifier}")
        print("Before...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)
    data = data.with_columns(
        pl.lit("").alias(f"value_{step}"),
        pl.lit(False).alias(f"success_{step}"),
        pl.lit(f"{step} error").alias(f"error_{step}"),
    )
    if field.type == "numeric":
        if field.numeric_modifier:
            if field.numeric_modifier.prefix or field.numeric_modifier.suffix:
                if field.numeric_modifier.prefix:
                    data = data.with_columns(
                        pl.when(pl.col(f"value_{src}").str.starts_with(field.numeric_modifier.prefix))
                        .then(
                            pl.col(f"value_{src}")
                            .str.strip_chars_start(field.numeric_modifier.prefix)
                            .cast(float)
                            .mul(field.numeric_modifier.multiplier)
                        )
                        .otherwise(pl.col(f"value_{src}").cast(float, strict=False))
                        .alias(f"value_{step}")
                    )
                elif field.numeric_modifier.suffix:
                    data = data.with_columns(
                        pl.when(pl.col(f"value_{src}").str.ends_with(field.numeric_modifier.suffix))
                        .then(
                            pl.col(f"value_{src}")
                            .str.strip_chars_end(field.numeric_modifier.suffix)
                            .cast(float, strict=False)
                            .mul(field.numeric_modifier.multiplier)
                        )
                        .otherwise(pl.col(f"value_{src}").cast(float, strict=False))
                        .alias(f"value_{step}")
                    )
            else:
                data = data.with_columns(
                    pl.col(f"value_{src}").cast(float, strict=False).mul(field.numeric_modifier.multiplier).alias(f"value_{step}")
                )
            if field.numeric_modifier.exclude_negative_values:
                data = data.with_columns(pl.when(pl.col(f"value_{step}") < 0).then(pl.lit(0.00)).alias(f"value_{step}"))
            if field.numeric_modifier.exclude_positive_values:
                data = data.with_columns(pl.when(pl.col(f"value_{step}") > 0).then(pl.lit(0.00)).alias(f"value_{step}"))
        else:
            data = data.with_columns(pl.col(f"value_{src}").cast(float, strict=False).alias(f"value_{step}"))
    elif field.type == "string":
        data = data.with_columns(pl.col(f"value_{src}").cast(str, strict=False).alias(f"value_{step}"))

    # cast the value back as a string so we don't get mixed types in the column value_cast column
    data = data.with_columns(pl.col(f"value_{step}").cast(str).fill_null("").alias(f"value_{step}"))
    if field.type == "numeric":
        data = data.with_columns(pl.col(f"value_{step}").str.to_decimal(scale=2).cast(str).alias(f"value_{step}"))

    data = data.with_columns(
        ((pl.col(f"value_{step}").is_not_null()) & (pl.col(f"value_{step}").str.len_bytes() > 0)).alias(f"success_{step}")
    ).with_columns(pl.when(pl.col(f"success_{step}")).then(None).otherwise(pl.col(f"error_{step}")).alias(f"error_{step}"))
    if DEBUG:
        print("After...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)
    log.append(["cast", time.time() - start])
    return data


def trim(data, field):
    start = time.time()
    src = "cast"
    step = "trim"
    if DEBUG:
        print(f"{step}: {field.string_max_length}")
        print("Before...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)
    data = data.with_columns(
        pl.lit("").alias(f"value_{step}"),
        pl.lit(False).alias(f"success_{step}"),
        pl.lit(f"{step} error").alias(f"error_{step}"),
    )
    string_max_length = field.string_max_length if field.string_max_length else 999
    if field.type == "string":
        data = data.with_columns(pl.col(f"value_{src}").str.head(string_max_length).fill_null("").alias(f"value_{step}"))
    else:
        data = data.with_columns(pl.col(f"value_{src}").fill_null("").alias(f"value_{step}"))
    data = data.with_columns(
        ((pl.col(f"value_{step}").is_not_null()) & (pl.col(f"value_{step}").str.len_bytes() > 0)).alias(f"success_{step}")
    ).with_columns(pl.when(pl.col(f"success_{step}")).then(None).otherwise(pl.col(f"error_{step}")).alias(f"error_{step}"))
    if DEBUG:
        print("After...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)
    log.append(["trim", time.time() - start])
    return data


def validate(data, field):
    start = time.time()
    src = "trim"
    if DEBUG:
        print("Validate")
        print("Before...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)

    data = data.with_columns(
        value=pl.col(f"value_{src}"),
        success=pl.concat_list(cs.starts_with("success_")).list.all(),
        error=pl.concat_list(cs.starts_with("error_")).list.drop_nulls().list.first(),
    ).with_columns(hard_fail=~pl.col("success") & field.vital)
    if DEBUG:
        print("After...")
        with pl.Config(tbl_cols=-1, tbl_rows=-1):
            print(data)
    log.append(["validate", time.time() - start])
    return data


def cleanup(data):
    start = time.time()
    if not DEBUG:
        data = data.select("section", "location", "config", "row", "page", "field", "vital", "value", "success", "error", "hard_fail")
    log.append(["cleanup", time.time() - start])
    return data


def extract_fields(pdf, location, statement_table, config_field, config, section, location_id):
    start = time.time()
    results: pl.DataFrame = pl.DataFrame()
    result: pl.LazyFrame = pl.LazyFrame()
    region, exception = get_region(location, pdf)
    if not statement_table:
        if region and not exception:
            result = pl.LazyFrame(
                data=[
                    pl.Series("field", [config_field.field], dtype=pl.String),
                    pl.Series("vital", [config_field.vital], dtype=pl.Boolean),
                    pl.Series("value_raw", [region.extract_text()], dtype=pl.String),
                ]
            )
            result = result.select(
                pl.lit(section).alias("section"),
                pl.lit(location_id).alias("location"),
                pl.lit(config).alias("config"),
                pl.lit(0).alias("row"),
                pl.lit(location.page_number).alias("page"),
                pl.col("field"),
                pl.col("vital"),
                pl.col("value_raw"),
            )
            spec = None
            if config_field.type == "numeric":
                spec = currency_spec[config_field.numeric_currency]
            result = (
                result.pipe(strip, config_field, spec)
                .pipe(patmatch, config_field, spec)
                .pipe(cast, config_field)
                .pipe(trim, config_field)
                .pipe(validate, config_field)
                .pipe(cleanup)
            )
            try:
                results.vstack(result.collect(), in_place=True)
            except pl.exceptions.ColumnNotFoundError:
                log.append(["extract_fields_exception", time.time() - start])
                return results.lazy()

    else:  # if there is a statement table
        table = get_table(location, region, statement_table) if region and not exception else pl.LazyFrame()
        table = table.collect().lazy()

        if not statement_table.transaction_spec:
            table_eager: pl.DataFrame = table.collect()
            for field in statement_table.fields:
                result = pl.LazyFrame(
                    data=[
                        pl.Series("field", [field.field], dtype=pl.String),
                        pl.Series("vital", [field.vital], dtype=pl.Boolean),
                        pl.Series("value_raw", [table_eager.item(field.cell.row, field.cell.col)], dtype=pl.String),
                    ]
                )
                result = result.select(
                    pl.lit(section).alias("section"),
                    pl.lit(location_id).alias("location"),
                    pl.lit(config).alias("config"),
                    pl.lit(field.cell.row).alias("row"),
                    pl.lit(location.page_number).alias("page"),
                    pl.col("field"),
                    pl.col("vital"),
                    pl.col("value_raw"),
                )
                spec = None
                if field.type == "numeric":
                    spec = currency_spec[field.numeric_currency]
                result = (
                    result.pipe(strip, field, spec)
                    .pipe(patmatch, field, spec)
                    .pipe(cast, field)
                    .pipe(trim, field)
                    .pipe(validate, field)
                    .pipe(cleanup)
                )
                try:
                    results.vstack(result.collect(), in_place=True)
                except pl.exceptions.ColumnNotFoundError:
                    continue

        else:  # transaction records will be multi-line and have now row specification
            for field in statement_table.fields:
                result = table.select(
                    section=pl.lit(section),
                    location=pl.lit(location_id),
                    config=pl.lit(config),
                    page=pl.lit(location.page_number),
                    field=pl.lit(field.field),
                    vital=pl.lit(field.vital),
                    value_raw=pl.nth(field.column),
                ).with_row_index("row")
                spec = None
                if field.type == "numeric":
                    spec = currency_spec[field.numeric_currency]
                result = (
                    result.pipe(strip, field, spec).pipe(patmatch, field, spec).pipe(cast, field).pipe(trim, field).pipe(validate, field)
                    # .pipe(cleanup)
                )
                try:
                    results.vstack(result.collect(), in_place=True)
                except pl.exceptions.ColumnNotFoundError:
                    continue
            # Transaction bookends
            bookends = statement_table.transaction_spec.transaction_bookends
            start_line = bookends.start_fields
            end_line = bookends.end_fields
            start_rows = (
                results.filter(pl.col("field").is_in(start_line))
                .group_by("row")
                .agg(pl.col("success").implode())
                .filter(pl.col("success").list.count_matches(True) >= bookends.min_non_empty_start)
                .select(pl.col("row"), transaction_start=pl.lit(True))
            )
            end_rows = (
                results.filter(pl.col("field").is_in(end_line))
                .group_by("row")
                .agg(pl.col("success").implode())
                .filter(pl.col("success").list.count_matches(True) >= bookends.min_non_empty_end)
                .select(pl.col("row"), transaction_end=pl.lit(True))
            )
            results = (
                results.join(start_rows, on="row", how="left", validate="m:1")
                .join(end_rows, on="row", how="left", validate="m:1")
                .with_columns(
                    transaction_start=pl.col("transaction_start").fill_null(False),
                    transaction_end=pl.col("transaction_end").fill_null(False),
                )
            )
    log.append([f"extract_fields_{'stmt' if statement_table and statement_table.transaction_spec else 'std'}", time.time() - start])
    return results.lazy()


def process_transactions(data, transaction_spec):
    start = time.time()
    data = (
        data.filter(pl.col("success"))
        .pivot(values="value", index=["page", "row", "transaction_start", "transaction_end"], on="field")
        .sort("page", "row")
        .lazy()
    )  # pivot the data
    data = data.with_columns(transaction_number=pl.col("transaction_start").cum_sum()).filter(
        pl.col("transaction_number") > 0
    )  # number the transactions and remove rows before the 1st
    if fffs := transaction_spec.fill_forward_fields:  # fill forward if there are any fields in the spec
        for fff in fffs:
            data = data.with_columns(
                pl.col(fff).fill_null(strategy="forward").alias(fff),
            )
    if mfs := transaction_spec.merge_fields:
        for mf in mfs.fields:
            data = data.with_columns(
                pl.col(mf).str.join(delimiter=mfs.separator).over("transaction_number"),
            )
    data = data.filter(pl.col("transaction_end"))
    std_date = transaction_spec.std_date
    std_date_field = std_date.field
    std_date_format = std_date.date_format
    std_credit = transaction_spec.std_credit
    std_credit_field = std_credit.field
    std_credit_multiplier = 1 if not std_credit.numeric_modifier else std_credit.numeric_modifier.multiplier
    std_debit = transaction_spec.std_debit
    std_debit_field = std_debit.field
    std_debit_multiplier = 1 if not std_debit.numeric_modifier else std_debit.numeric_modifier.multiplier
    std_description = transaction_spec.std_description
    std_description_field = std_description.field

    data = (
        data.with_columns(
            std_date=pl.col(std_date_field).str.to_date(format=std_date_format),
            std_credit=pl.col(std_credit_field).cast(float).mul(std_credit_multiplier).fill_null(0),
            std_debit=pl.col(std_debit_field).cast(float).mul(std_debit_multiplier).fill_null(0),
            std_description=pl.col(std_description_field),
        )
        .with_columns(
            std_movement=pl.col("std_credit").sub(pl.col("std_debit")).cast(str).str.to_decimal(scale=2),
            std_credit=pl.col("std_credit").cast(str).str.to_decimal(scale=2),
            std_debit=pl.col("std_debit").cast(str).str.to_decimal(scale=2),
        )
        .drop("transaction_start", "transaction_end")
    )
    # with pl.Config(tbl_cols=-1, tbl_rows=-1):
    #     print(data.collect())

    log.append(["process_transactions", time.time() - start])
    return data.collect()


def get_results(pdf, section, config: Config, scope="success") -> pl.DataFrame:  # scope can be all, success, fail, or hard_fail
    start = time.time()
    result: pl.LazyFrame = pl.LazyFrame()
    results: pl.DataFrame = pl.DataFrame()
    locations = config.statement_table.locations if config.statement_table else config.locations
    spawned_locations = spawn_locations(locations, stmt.pdf)
    for i, location in enumerate(spawned_locations):
        result = extract_fields(pdf, location, config.statement_table, config.field, config.config, section=section, location_id=i)
        results.vstack(result.collect(), in_place=True)

    if statement_table := config.statement_table:
        # process transactions if there's a transaction spec
        if spec := statement_table.transaction_spec:
            results = results.pipe(process_transactions, spec)
            log.append(["get_results_stmt_transaction", time.time() - start])
            return results
        elif statement_table.type == "summary":  # summary tables should have some standard fields
            results = results.pivot(values="value", index="section", on="field")
            if sob := statement_table.std_opening_balance:
                multiplier = 1 if not sob.numeric_modifier else sob.numeric_modifier.multiplier
                results = results.with_columns(std_opening_balance=pl.col(sob.field).cast(float).mul(multiplier).fill_null(0))
            if scb := statement_table.std_closing_balance:
                multiplier = 1 if not scb.numeric_modifier else scb.numeric_modifier.multiplier
                results = results.with_columns(std_closing_balance=pl.col(scb.field).cast(float).mul(multiplier).fill_null(0))
            if ssc := statement_table.std_statement_credits:
                multiplier = 1 if not ssc.numeric_modifier else ssc.numeric_modifier.multiplier
                results = results.with_columns(std_statement_credits=pl.col(ssc.field).cast(float).mul(multiplier).fill_null(0))
            if ssd := statement_table.std_statement_debits:
                multiplier = 1 if not ssd.numeric_modifier else ssd.numeric_modifier.multiplier
                results = results.with_columns(std_statement_debits=pl.col(ssd.field).cast(float).mul(multiplier).fill_null(0))
            log.append(["get_results_stmt_summary", time.time() - start])
            return results

    if scope == "all":
        log.append(["get_results_all", time.time() - start])
        return results
    elif scope == "success":
        log.append(["get_results_success", time.time() - start])
        return results.filter(pl.col("success"))
    elif scope == "fail":
        log.append(["get_results_fail", time.time() - start])
        return results.filter(~pl.col("success"))
    elif scope == "hard_fail":
        log.append(["get_results_hard_fail", time.time() - start])
        return results.filter(pl.col("hard_fail"))
    else:
        log.append(["get_results_default", time.time() - start])
        return results


def pick_leaf(leaves, pdf):
    start = time.time()
    result: tuple | None = None
    if isinstance(leaves, dict):
        for key, leaf in leaves.items():
            config = leaf.config
            leaf_result = get_results(pdf, "pick", config, scope="success")
            if len(leaf_result) > 0:
                result = (leaf, key)
                break
    elif isinstance(leaves, list):
        for leaf in leaves:
            config = leaf.config
            leaf_result = get_results(pdf, "pick", config, scope="success")
            if len(leaf_result) > 0:
                result = (leaf, "")
                break
    else:
        raise TypeError("the pick_leaf() function requires leaves to be a dictionary or list")
    if not result:
        raise StatementError("the account cannot be identified from your statement")
    log.append(["pick_leaf", time.time() - start])
    return result


def get_config_from_account(account_key, file_path):
    start = time.time()
    config_account = config_accounts.get(account_key)
    if not config_account:
        raise StatementError(f"Unable to identify the account from the statement provided: {file_path}")
    else:
        log.append(["get_config_from_account", time.time() - start])
        return config_account


def get_config_from_company(company_key, pdf, file_path):
    start = time.time()
    company_accounts = None
    config_account = None
    try:
        company_accounts = config_company_accounts(company_key)
    except KeyError:
        print(f"{company_key} is not a valid company key")
    if company_accounts:
        try:
            config_account = pick_leaf(leaves=company_accounts, pdf=pdf)[0]
        except StatementError:
            config_account = None
    if not config_account:
        raise StatementError(f"Unable to identify the account from the statement provided: {file_path}")
    log.append(["get_config_from_company", time.time() - start])
    return config_account


def get_config_from_statement(pdf, file_path):
    start = time.time()
    company_leaf = pick_leaf(leaves=config_companies, pdf=pdf)
    if not company_leaf:
        raise StatementError(f"Unable to identify the company from the statement provided: {file_path}")
    company_key = company_leaf[1]
    config_account = None
    try:
        config_account = get_config_from_company(company_key, pdf, file_path)
    except Exception as e:
        raise StatementError(f"Unable to identify the account from the statement provided: {file_path}") from e
    log.append(["get_config_from_statement", time.time() - start])
    return config_account


def get_config(self):
    start = time.time()
    config = None
    if self.account_key:
        config = get_config_from_account(self.account_key, self.file_path)
    elif self.company_key:
        config = get_config_from_company(self.company_key, self.pdf, self.file_path)
    else:
        config = get_config_from_statement(self.pdf, self.file_path)
    log.append(["get_config", time.time() - start])
    return config


start_all = time.time()

config = get_config(stmt)
company = config.company.company if config.company and hasattr(config.company, "company") else ""
account = config.account if config and hasattr(config, "account") else ""
statement_type = (
    config.statement_type.statement_type if config.statement_type and hasattr(config.statement_type, "statement_type") else None
)
config_header = config.statement_type.header.configs if config.statement_type and hasattr(config.statement_type, "header") else None
config_pages = config.statement_type.pages.configs if config.statement_type and hasattr(config.statement_type, "pages") else None
config_lines = config.statement_type.lines.configs if config.statement_type and hasattr(config.statement_type, "lines") else None

start_header = time.time()

if config_header:
    results: pl.DataFrame = pl.DataFrame()
    for config in config_header:
        results.vstack(get_results(stmt.pdf, "header", config, scope="success"), in_place=True)
    results = results.pivot(values="value", index="section", on="field")
    with pl.Config(tbl_cols=-1, tbl_rows=-1):
        print(results)
        ...

end_header = time.time()
start_pages = time.time()

if config_pages:
    results: pl.DataFrame = pl.DataFrame()
    for config in config_pages:
        results.vstack(get_results(stmt.pdf, "pages", config, scope="success"), in_place=True)
    results = results.pivot(values="value", index=["page"], on="field")
    with pl.Config(tbl_cols=-1, tbl_rows=-1):
        print(results)
        ...
end_pages = time.time()

start_lines = time.time()

if config_lines:
    results: pl.DataFrame = pl.DataFrame()
    for config in config_lines:
        results.vstack(get_results(stmt.pdf, "lines", config, scope="success"), in_place=True)
    with pl.Config(tbl_cols=-1, tbl_rows=-1):
        print(results)
        ...
end_lines = time.time()

log.append(["Total Time", time.time() - start_all])

log_times = (
    pl.DataFrame(log, strict=False)
    .transpose(column_names=["function", "seconds"])
    .group_by(pl.col("function"))
    .agg(total_seconds=pl.col("seconds").cast(float).fill_null(0).sum(), total_calls=pl.col("function").count())
    .sort("total_seconds", descending=True)
)

with pl.Config(tbl_cols=-1, tbl_rows=-1):
    print(log_times)
