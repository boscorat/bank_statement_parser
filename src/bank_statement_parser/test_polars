import polars as pl

# def ack(m, n):
#     if not m:
#         return n + 1
#     if not n:
#         return ack(m - 1, 1)
#     return ack(m - 1, ack(m, n - 1))


# values = pl.DataFrame(
#     {
#         "m": [0, 0, 0, 1, 1, 1, 2],
#         "n": [2, 3, 4, 1, 2, 3, 1],
#     }
# )
# result = values.with_columns(pl.struct(["m", "n"]).map_elements(lambda s: ack(s["m"], s["n"]), return_dtype=pl.Int64).alias("ack"))

# print(result)


def field_value_cast(value: str, type: str) -> tuple[bool, str]:
    exp = f"{type}('{value}')"  # build the initial expression
    success: bool = False
    exception: str = ""
    try:  # try to evaluate the cast
        result = eval(exp)
    except ValueError:
        exception = f"<CAST FAILURE: '{value}' is not of type {type}>"  # if the conversion formula is valid, but the cast fails
    except NameError:  # if the formula fails to evaluate
        type_short = type[0:4]  # try shortening the type to catch bool's passed as 'boolean'
        exp = f"{type_short}('{value}')"  # rebuild the formula
        try:  # try to evaluate the shorter form
            result = eval(exp)
        except ValueError:
            exception = f"<CAST FAILURE: '{value}' is not of type {type}>"
        except NameError:  # still not working? try an even shorter form to catch int and str passed as integer and string
            type_shortest = type[0:3]
            exp = f"{type_shortest}('{value}')"
            try:
                result = eval(exp)
            except ValueError:
                exception = f"<CAST FAILURE: '{value}' is not of type {type}>"
            except NameError:
                exception = f"<CAST FAILURE: {type} is not a valid type>"
    success = True if result else False
    return (success, exception)


values = pl.DataFrame(
    {
        "m": ["bob", "sue", "23", "15.4"],
        "n": ["str", "str", "int", "float"],
    }
)
result = values.with_columns(
    pl.struct(["m", "n"]).map_elements(lambda s: field_value_cast(s["m"], s["n"])[0], return_dtype=pl.Boolean).alias("ack")
)
print(result)
